\section{Obiettivo}
L'obiettivo di questo progetto è quello di realizzare un programma scritto in \textbf{OCaml} che risolva il \textit{problema} della \textit{colorazione di un grafo}: riuscire a colorare, se possibile, ogni nodo del grafo in modo da non avere mai nodi adiacenti con lo stesso colore. In via più formale, dato un grafo \lstinline[style=cmd]|g| ed un numero massimo di colori utilizzabili \lstinline[style=cmd]|N|, assegnare un colore ( da $0$ a $N-1$) ai nodi in modo tale che non esistano nodi adiacenti con lo stesso colore; qualora il numero di colori \lstinline[style=cmd]|N| non sia sufficiente per realizzare la colorazione, riportare un errore.
 
\section{Struttura del Progetto}
%TODO: aggiungere la struttura del progetto. forse va bene una foto o il risultato di un LS.
Di seguito sarà riportata la struttura delle cartelle e dei file del progetto con una breve descrizione per quelli più importanti. I file OCaml sono divisi in base al compito che svolgono le funzioni al loro interno (\textit{e.g.: \lstinline[style=cmd]|graphUtils| conterrà le funzioni che operano sui grafi, ecc.}) e sono sempre formati da un file \lstinline[style=cmd]|.ml| che contiene il copro della funzione con tutte le varie espressioni ed un file \lstinline[style=cmd]|.mli| nel quale è presente solo il tipo delle funzioni ed espressioni che verranno utilizzate dagli altri file. %TODO: rivedere meglio

\begin{figure}[H]
	\dirtree{%
		.1 .
		.1 Makefile.
		.1 src.
		.2 main.ml.
		.2 main.mli.
		.2 graphUtils.ml.
		.2 graphUtils.mli.
		.2 data.ml.
		.2 data.mli.
		.2 printer.ml.
		.2 printer.mli.
		.2 rappresentazione\_grafo.
		.3 rappresentazione\_grafo.py.
	}
	\caption{Rappresentazione schematizzata dei file e cartelle del progetto.}
\end{figure}

\begin{itemize}
	\item \lstinline[style=cmd]|Makefile|: utilizzato per compilare il progetto e generare l'eseguibile per avviarlo (vedere ...)	%TODO: aggiungere riferimento
	\item \lstinline[style=cmd]|main|: contiene la funzione principale che si occupa di avviare la colorazione e di gestire le scelte fatte dall'utente
	\item \lstinline[style=cmd]|graphUtils|: insieme di funzioni che operano sui grafi che svolgono l'effettivo compito di colorazione
	\item \lstinline[style=cmd]|data|: insieme di grafi per testare il corretto funzionamento del progetto. Questi possono essere aggiunti e rimossi in modo semplice ed efficiente
	\item \lstinline[style=cmd]|printer|: insieme di funzioni ed espressioni per stampare a video menu ed altri elementi con anche la presenza di colori ed emoji
	\item \lstinline[style=cmd]|rappresentazione\_grafo|: script in python per rappresentare a video (in modo interattivo) un grafo
\end{itemize}
\ \\
Una volta utilizzato il comando \lstinline[style=cmd]|make| per compilare il progetto, la struttura finale delle cartelle sarà la seguente:

\begin{figure}[H]
	\dirtree{%
		.1 .
		.1 bin.
		.2 exe.
		.2 rappresentazione\_grafo.py.
		.1 build.
		.2 data.cmo.
		.2 graphUtils.cmo.
		.2 main.cmo.
		.2 printer.cmo.
		.1 Makefile.
		.1 src.
		.2 data.cmi.
		.2 data.ml.
		.2 data.mli.
		.2 graphUtils.cmi.
		.2 graphUtils.ml.
		.2 graphUtils.mli.
		.2 main.cmi.
		.2 main.ml.
		.2 main.mli.
		.2 printer.cmi.
		.2 printer.ml.
		.2 printer.mli.
		.2 rappresentazione\_grafo.
		.3 rappresentazione\_grafo.py.
	}
	\caption{Rappresentazione dei file e cartelle del progetto dopo averlo compilato.}
\end{figure}
\ \\
I file \lstinline[style=cmd]|.cmi| vengono lasciati all'interno della cartella \lstinline[style=cmd]|src| per far funzionare correttamente l'estensione di \textbf{OCaml} per \textbf{Visual Studio Code}. 
\section{Codice}
%TODO: spiegare prima come vengono rappresentati i colori (tipo il fatto che -1 vuol dire non colorato). E spiegare brevemente alcune funzioni importanti, non tutte ed in modo veloce e conciso.
\subsection{Rappresentazione di un Grafo}
In questo progetto i grafi (si parla sempre di grafi \textit{orientati/diretti}) vengono rappresentati come una \textit{tupla} di 3 elementi:

\begin{enumerate}
	\item \textbf{\lstinline[style=cmd]|succ|}: funzione successori che definisce tutti i successori (nodi vicini) di tutti i nodi del grafo
	\item \textbf{\lstinline[style=cmd]|start|}: nodo di partenza per la colorazione
	\item \textbf{\lstinline[style=cmd]|maxColors|}: numero massimo di colori da utilizzare durante la colorazione
\end{enumerate}
\ \\
Di seguito un esempio di definizione di un grafo con la sua rappresentazione: 
\begin{figure}[H]
	\begin{subfigure}[b]{.5\textwidth}
\begin{lstlisting}[style=caml]
let grafo_1 =
	let x = function        
		  0 -> [1; 2]
		| 1 -> [0; 2; 3]
		| 2 -> [0; 1]
		| 3 -> [1; 4]
		| 4 -> [3]
		| 5 -> [6]
		| _ -> [] in
	let start = 3 in
	let maxColors = 3 in
	let succ = Successori x in
	
	(Grafo (succ, start, maxColors))
;;
\end{lstlisting}
\caption{Esempio di definizione di un grafo}
	\end{subfigure}%
	\begin{subfigure}[b]{.5\textwidth}
			\centering
			\includegraphics[width=.8\linewidth]{img/grafoesempio1.png}
			\caption{Grafo prodotto dal codice (a)}
	\end{subfigure}%
\end{figure}
\ \\
Il tipo \lstinline[style=cmd]|grafo| e \lstinline[style=cmd]|succesori|  sono definiti in \lstinline[style=cmd]|graphUtils| nel seguente modo:

\begin{lstlisting}[style=caml]
	type successori = Successori of (int -> int list);;
	type grafo 			= Grafo of successori * int * int;;
\end{lstlisting}

\subsection{Data}
In questo file ci sono tutte le definizioni dei grafi utilizzati come test per verificare il corretto funzionamento dell'algoritmo di colorazione, una funzione che permette di stampare un menù per la selezione di un grafo (con la descrizione del grafo e un ID unico) da parte dell'utente ed una funzione che dato un numero, ritorna uno dei grafi detti prima.
\`{E} anche presente una lista \lstinline[style=cmd]|grafi| che contiene tutti i grafi disponibili con una descrizione (una coppia \lstinline[style=cmd]|(grafo, string)|), è questa che permette di aggiungere e togliere grafi in maniera semplice e senza dover modificare alcuna funzione.

\begin{lstlisting}[style=caml, caption={Lista di coppie (grafo,string) utilizzata per assiocare ad un grafo una descrizione.}]
let grafi = [
	(grafo_1,   "Grafo 1"); 
	(grafo_2,   "Grafo 2 con numero sufficiente di colori"); 
	(grafo2err, "Grafo 2 con colori insufficienti"); 
	(grafo_3,   "Grafo 3"); 
	(grafo_4,   "Grafo 4")
];;
\end{lstlisting}
\ \\
La funzione \lstinline[style=cmd]|stampa_grafi_disponibili| mostra a video la descrizione dei vari grafi anteceduta da un ID. Questa scandisce la lista \lstinline[style=cmd]|grafi| ricorsivamente e va a stampare il secondo elemento di ogni coppia.

\begin{figure}[H]
	\begin{subfigure}{\textwidth}

\begin{lstlisting}[style=caml]
let stampa_grafi_disponibili () = 
	let rec aux id = function (*lista di grafi*)
		  []      -> print_string "\n"    (*caso base, stampa un \n*)
		| x::coda ->                      (*stampa descrizione ed id*)
			let stampa_elemento (_, descrizione) = 
				print_string "  "; 
				print_int id; print_string (") " ^ descrizione ^ "\n")

			(*id + 1 e continua con la coda*)
			in  stampa_elemento x;    
				  aux (id+1) coda     

	in aux 1 grafi  (*avvia aux*)
;;
\end{lstlisting}
		\caption{Funzione per la stampa a video delle descrizione dei grafi antecedute da un ID}
	\end{subfigure}
\ \\
\ \\
	\begin{subfigure}{\textwidth}
		\includegraphics[width=\textwidth]{img/descrizione_grafi.png}
		\caption{Output del codice (a)}
	\end{subfigure}
\end{figure}

\ \\
Infine, al funzione \lstinline[style=cmd]|scegli_grafo| che, dato un ID, ritorna il relativo grafo. \`{E} interessante notare come per selezionare un dato grafo non viene scorsa ricorsivamente tutta la lista, ma quest'utlima viene convertita in un \lstinline[style=cmd]|Array| per poter utilizzare il metodo \lstinline[style=cmd]|get| per accedere all'i-esima posizione. Vengono effettuati alcuni controlli sull'input: viene controllato se l'ID passato è valido (non superi per eccesso, o per difetto gli ID mostrati a video) e nel caso solleva un'eccezione (verrà utilizzata nella funzione \lstinline[style=cmd]|main| per segnalare il problema). %TODO: aggiungere riferimento

\begin{lstlisting}[style=caml, caption={Funzione che ritorna il grafo selezionato}]
let scegli_grafo id_grafo =
	let array_tmp = Array.of_list grafi in    (*lista in array*)
		if id_grafo > Array.length array_tmp || (*controlla id*)
		   id_grafo < 1  
			then 
				raise BadChoice    (* se non e valido lancia un'eccezione*)
		else
			fst (Array.get array_tmp (id_grafo-1))   (*ritorna grafo*)
;; 
\end{lstlisting}

\subsection{Printer}

In questo file risiedono tutte le funzioni e dichiarazioni che gestiscono la stampa a video. Vi è una definizione di caratteri per stampare su terminale (deve ovviamente supportare le emoji e i vari colori) caratteri colorati (rosso, verde, blu, ecc.), elementi in grassetto ed emoji. La funzione più degna di nota è \lstinline[style=cmd]|stampa_grafo| che, dato un grafo, stampa a schermo tutti i nodi con i suoi vicini (in pratica rappresenta la funzione successori).\\
\ \\
Di seguito alcuni dei codici utilizzati per rappresentare i colori nel terminale: 

\begin{lstlisting}[style=caml, caption={Codici per i colori ed elementi in grassetto}]
	type colore = Colore of string;;
	
	(* normali *)
	let rosso = Colore "\027[31m";;
	let verde = Colore "\027[32m";;
	let ciano =  Colore "\027[36m";;
	let bianco = Colore "\027[0m";;
	
	(* grassetto *)
	let rosso_b = Colore "\027[31;1m";;
	let verde_b = Colore "\027[32;1m";;
	let ciano_b = Colore "\027[36;1m";;
	let bianco_b = Colore "\027[0;1m";;
	
	(* valore di reset per stampare normalmente*)
	let reset = bianco;;
\end{lstlisting}

\begin{figure}[H]
\begin{subfigure}{\textwidth}
\begin{lstlisting}[style=caml]
let stampa_grafo (Grafo((Successori succ), partenza, maxColori)) =
	print_colore rosso_b "Partenza: ";
	print_int partenza; print_colore rosso_b " Max Colori: ";
	print_int maxColori; print_string "\n\n";
	let rec search visitati = function  (* frontiera *)
		  [] 				 -> print_string "\n"    (*caso base, stampa \n*)      
		| nodo::coda ->                      (*stampa nodo e vicini*)
			if List.mem nodo visitati     (* ignora nodi visti*)
				then 
					search visitati coda
			else                          (* stampa il nodo e vicini.*)
				(print_colore verde_b (string_of_int nodo); 
				print_colore bianco_b " -> "; stampa_lista (succ nodo); 
				search (visitati@[nodo]) (coda@(succ nodo)))

	in search [] [partenza]   (*avvia la ricorsione*)
;;
\end{lstlisting}
\caption{Funzione per la stampa di un grafo su terminale}
\end{subfigure}
\ \\
\ \\
\begin{subfigure}{\textwidth}
	\centering
	\includegraphics[width=\textwidth]{img/grafoTerminale.png}
	\caption{Output della funzione (a)}
\end{subfigure}
\end{figure}



\subsection{GraphUtils}

\subsection{Main}

\subsection{Python}

\subsection{Makefile}

File utilizzato per la compilazione del progetto che avviene tramite il comando \lstinline[style=cmd]|make|. 
Qualora un file venga modificato, questo permette di non dover ricompilare tutto il progetto ma solo quello che è stato cambiato. In una prima fase compila tutti i file \lstinline[style=cmd]|.ml| con i relativi \lstinline[style=cmd]|.mli|, generando 2 altri file:

\begin{itemize}
	\item \lstinline[style=cmd]|.cmi|: interfacce compilate utili per il corretto funzionamento dell'estensione \textit{OCaml} in \textit{Visual Studio Code} e per la corretta compilazione degli altri file.
	\item \lstinline[style=cmd]|.cmo|: file oggetto che verranno poi spostati nella cartella \lstinline[style=cmd]|build| per essere utilizzati nella fase di \textit{linking}
\end{itemize}
\ \\
Quindi, ogni file \lstinline[style=cmd]|.cmo| dipende dai relativi file \lstinline[style=cmd]|.ml| e \lstinline[style=cmd]|.mli|.
Successivamente, avvia la fase di \textit{linking} unendo insieme tutti i file \lstinline[style=cmd]|.cmo| e generando l'eseguibile \lstinline[style=cmd]|exe| nella cartella \lstinline[style=cmd]|bin|. All'interno di quest'ultima copia anche lo script python per permettere il corretto funzionamento del progetto.

\begin{lstlisting}[style=make, caption={Breve estratto del file Makefile}]
cc = ocamlc
cflags = -c
cinclude = -I src

srcdir = src
buildir = build
bindir = bin

target = $(bindir)/exe

.PHONY: clear

all: cartelle $(target)


$(target): 
	$(buildir)/graphUtils.cmo $(buildir)/printer.cmo 
	$(buildir)/data.cmo $(buildir)/main.cmo
		$(cc) -o $@ $^
		cp $(srcdir)/rappresentazione_grafo/rappresentazione_grafo.py $(bindir)

\end{lstlisting}
\section{Dimostrazione}
%TODO: aggiungere foto e mostrare come funziona in pratica il progetto.





